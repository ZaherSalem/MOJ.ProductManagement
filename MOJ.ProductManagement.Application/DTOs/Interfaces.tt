<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".ts" #>
<#
    // Set custom output filename
    string projectPath = Path.GetDirectoryName(Host.TemplateFile);

    string outputPath = Path.Combine(projectPath, "../../", "MOJ.ProductManagement.Web.Client.Angular", "src/app/core/generated", "Interfaces.ts");
    
#>

<#
    // Type mapping dictionary
    var typeMap = new Dictionary<string, string> {
        {"string", "string"},
        {"int", "number"},
        {"long", "number"},
        {"decimal", "number"},
        {"double", "number"},
        {"float", "number"},
        {"bool", "boolean"},
        {"DateTime", "Date"},
        {"Guid", "string"},
        {"DomainException","any"}
    };

    //string projectPath = Path.GetDirectoryName(Host.TemplateFile);
    string dtosPath = Path.Combine(projectPath);

#>
/**
 * WARNING: This file is auto-generated.
 * Do not edit this file manually.
 * Generated on: <#= DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") #>
 */

<#
    foreach(string file in Directory.GetFiles(dtosPath, "*.cs", SearchOption.AllDirectories)) {
        string[] lines = File.ReadAllLines(file);
        string className = "";
        var properties = new List<(string Name, string Type)>();
        bool isGeneric = false;
        string genericParameter = "";
        
        foreach(string line in lines) {
            var classMatch = Regex.Match(line, @"public (?:class|interface) (\w+)(?:<(\w+)>)?");
            if(classMatch.Success) {
                className = classMatch.Groups[1].Value;
                if(classMatch.Groups.Count > 2 && !string.IsNullOrEmpty(classMatch.Groups[2].Value)) {
                    isGeneric = true;
                    genericParameter = classMatch.Groups[2].Value;
                }
                continue;
            }

            var propertyMatch = Regex.Match(line.Trim(), @"public\s+(\w+(?:<\w+>)?)\s+(\w+)\s*{\s*get;");
            if(propertyMatch.Success) {
                string propType = propertyMatch.Groups[1].Value;
                string propName = propertyMatch.Groups[2].Value;
                
                // Handle generic types
                if(propType.Contains("<")) {
                    var genericMatch = Regex.Match(propType, @"(\w+)<(\w+)>");
                    string genericType = genericMatch.Groups[1].Value;
                    string innerType = genericMatch.Groups[2].Value;
                    
                    if(genericType == "List" || genericType == "IEnumerable" || genericType == "ICollection") {
                        propType = $"{(typeMap.ContainsKey(innerType) ? typeMap[innerType] : innerType)}[]";
                    } else {
                        // Handle other generic types
                        propType = $"{genericType}<{(typeMap.ContainsKey(innerType) ? typeMap[innerType] : innerType)}>";
                    }
                } else {
                    propType = typeMap.ContainsKey(propType) ? typeMap[propType] : propType;
                }
                
                properties.Add((propName, propType));
            }
        }

        if(!string.IsNullOrEmpty(className)) {
            if(isGeneric) {
#>
export interface I<#= className #><T> {
<#
            } else {
#>
export interface I<#= className #> {
<#
            }
            foreach(var prop in properties) {
                // Replace generic parameter placeholder with T
                string propType = prop.Type;
                if(isGeneric && propType.Contains(genericParameter)) {
                    propType = propType.Replace(genericParameter, "T");
                }
#>
    <#= prop.Name #>: <#= propType #>;
<#
            }
#>
}

<#
        }
    }
#>

<#
    File.WriteAllText(outputPath, GenerationEnvironment.ToString());
#>