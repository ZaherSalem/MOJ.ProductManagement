<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".ts" #>
<#
    // Set custom output filename
    string projectPath = Path.GetDirectoryName(Host.TemplateFile);
    string outputPath = Path.Combine(projectPath, "../../", "MOJ.ProductManagement.Web.Client.Angular", "src/app/core/generated", "Interfaces.ts");
#>

<#
    // Type mapping dictionary
    var typeMap = new Dictionary<string, string> {
        {"string", "string"},
        {"string?", "string | null"},
        {"int", "number"},
        {"long", "number"},
        {"decimal", "number"},
        {"double", "number"},
        {"float", "number"},
        {"bool", "boolean"},
        {"DateTime", "Date"},
        {"Guid", "string"},
        {"DomainException","any"}
    };

    string dtosPath = Path.Combine(projectPath);
    var customTypes = new HashSet<string>();
    
    // First pass: collect all custom types
    foreach(string file in Directory.GetFiles(dtosPath, "*.cs", SearchOption.AllDirectories)) {
        string[] lines = File.ReadAllLines(file);
        foreach(string line in lines) {
            var classMatch = Regex.Match(line, @"public (?:class|interface) (\w+)(?:<(\w+)>)?");
            if(classMatch.Success) {
                customTypes.Add(classMatch.Groups[1].Value);
            }
        }
    }
#>
/**
 * WARNING: This file is auto-generated.
 * Do not edit this file manually.
 * Generated on: <#= DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") #>
 */

<#
    // Second pass: generate interfaces
    foreach(string file in Directory.GetFiles(dtosPath, "*.cs", SearchOption.AllDirectories)) {
        string[] lines = File.ReadAllLines(file);
        string className = "";
        var properties = new List<(string Name, string Type)>();
        bool isGeneric = false;
        string genericParameter = "";
        
        foreach(string line in lines) {
            var classMatch = Regex.Match(line, @"public (?:class|interface) (\w+)(?:<(\w+)>)?");
            if(classMatch.Success) {
                className = classMatch.Groups[1].Value;
                if(classMatch.Groups.Count > 2 && !string.IsNullOrEmpty(classMatch.Groups[2].Value)) {
                    isGeneric = true;
                    genericParameter = classMatch.Groups[2].Value;
                }
                continue;
            }

            var propertyMatch = Regex.Match(line.Trim(), @"public\s+(\w+(?:<\w+>)?(?:\??))\s+(\w+)\s*{\s*get;");
            if(propertyMatch.Success) {
                string propType = propertyMatch.Groups[1].Value;
                string propName = propertyMatch.Groups[2].Value;
                bool isNullable = propType.EndsWith("?");
                
                // Remove nullable marker for processing
                if (isNullable) {
                    propType = propType.Substring(0, propType.Length - 1);
                }
                
                // Handle generic types
                if(propType.Contains("<")) {
                    var genericMatch = Regex.Match(propType, @"(\w+)<(\w+)>");
                    string genericType = genericMatch.Groups[1].Value;
                    string innerType = genericMatch.Groups[2].Value;
                    
                    if(genericType == "List" || genericType == "IEnumerable" || genericType == "ICollection") {
                        propType = $"{(typeMap.ContainsKey(innerType) ? typeMap[innerType] : "I" + innerType)}[]";
                    } else {
                        // Handle other generic types
                        propType = $"{genericType}<{(typeMap.ContainsKey(innerType) ? typeMap[innerType] : "I" + innerType)}>";
                    }
                } else {
                    // Check if this is a custom type
                    if (customTypes.Contains(propType)) {
                        propType = "I" + propType;
                    } else {
                        propType = typeMap.ContainsKey(propType) ? typeMap[propType] : propType;
                    }
                }
                
                // Add back nullable marker if needed
                if (isNullable) {
                    propType += " | null";
                }
                
                properties.Add((propName, propType));
            }
        }

        if(!string.IsNullOrEmpty(className)) {
            if(isGeneric) {
#>
export interface I<#= className #><T> {
<#
            } else {
#>
export interface I<#= className #> {
<#
            }
            foreach(var prop in properties) {
                // Replace generic parameter placeholder with T
                string propType = prop.Type;
                if(isGeneric && propType.Contains(genericParameter)) {
                    propType = propType.Replace(genericParameter, "T");
                }
#>
    <#= prop.Name #>: <#= propType #>;
<#
            }
#>
}

<#
        }
    }
#>

<#
    File.WriteAllText(outputPath, GenerationEnvironment.ToString());
#>